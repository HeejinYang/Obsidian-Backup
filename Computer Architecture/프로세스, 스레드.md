## 프로세스

프로세스는 현재 실행중인 프로그램, 프로세스가 생성 되었다고 표현한다 (데이터가 메모리에 올라옴)

보이는 곳에서 실행되는 프로세스 = 포그라운드 프로세스
보이지 않는 곳에서 실행되는 프로세스 = 백그라운드 프로세스
그중에서 사용자와 상호작용 하지 않는 프로세스 = 서비스(윈도우), 데몬(리눅스)

프로세스를 식별하기 위한 정보는 pcb에 들어있다, process control block, 커널영역에 생성됨
cpu는 한번에 하나의 프로세스만 실행할 수 있기 때문에 프로세스를 실행하는 데 필요한 문맥을 백업하고 가져오면서 계속 실행하는 프로세스를 바꾼다 이것을 문맥 교환이라함 context switching

## 메모리에 올라온 프로세스
\# 커널영역
pcb저장

\# 사용자영역
코드영역, 데이터영역, 스택영역, 힙영역으로 나뉘어서 올라온다

- 코드영역
cpu가 사용할 명령어가 저장된다
읽기만 가능한 영역

- 데이터 영역
프로그램을 실행하는 동안 유지할 데이터가 저장된다
전역변수

>코드영역과 데이터 영역은 공간의 크기가 일정하기 때문에 정적할당영역이다

- 힙영역
프로그래머가 할당해서 쓰는 영역
안쓰는 공간은 반환해야한다, 반환하지 않으면 메모리 낭비인 메모리 누수가 발생한다

- 스택영역
일시적으로 쓰는 데이터를 저장한다
지역변수, 매개변수

> 힙영역과 스택영역은 공간의 크기가 변하기 때문에 동적할당영역이라 함

스택은 주소가 큰곳에서 낮은곳으로, 힙은 주소가 낮은 곳에서 큰곳으로 데이터를 저장한다


## 프로세스 상태, 계층

프로세스는 상태가 있다
생성, 준비, 실행, 종료
실행중에 입출력 인터럽트를 받으면 입출력이 끝날때까지 대기상태가 되고
입출력이 끝나면 준비상태가 되어 실행을 기다린다 (cpu를 사용하는 자기 차례를 기다림)

프로세스에 계층이 있고
부모프로세스가 자식 프로세스를 만든다
만들때 fork 시스템 호출을 이용해 자기자신의 복사본을 만들고 (pid는 다르다)
복사해서 만들어진 프로세스가 exec 시스템 호출로 필요한 정보로 덮어써진다

> 복사와 덮어쓰기로 새로운 자식 프로세스를 만든다


---

## 스레드

프로세스의 실행흐름의 단위
하나의 프로세스에서 여러 스레드 동시에 실행 가능

단일 실행흐름의 프로세스 여러개 실행하기 vs 하나의 프로세스에서 여러 스레드 실행하기

프로세스는 각자 독립적인 메모리 공간을 차지하기 때문에 메모리 낭비가 될수있다
스레드는 코드,데이터,힙 영역을 공유한다


---

리눅스는 프로세스와 스레드를 구분하지 않는다