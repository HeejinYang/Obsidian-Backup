## 가상메모리
가상메모리는 실행하고자 하는 프로그램의 일부만 메모리에 적재해서 실행하는 기술
가상메모리를 이용해서 실제 프로세스의 크기보다 큰 프로세스를 실행할수있다

이 가상메모리를 관리하는 기법에 크게 페이징과 세그멘테이션이 있다

## 페이징
가상메모리를 관리하는 기법이다
페이징기법은 프로세스를 페이지단위로 나눠서 메모리에 할당하여 외부단편화 문제를 해결하는것 + 프로세스의 일부만 메모리에 올리는것

페이징기법은 프로세스를 페이지 단위로 나누고 메모리를 프레임 단위로 나눠서 페이지를 프레임에 할당하는것이다

이를 이용해 메모리에 프로세스 전체를 연속적으로 할당했을때 생기는 메모리 낭비인 외부 단편화문제는 해결할수있지만 내부 단편화 문제가 생긴다

<내부단편화>
페이지 내부에 빈공간이 발생하는것
페이지의 크기를 적당히 작게해서 해결한다, 너무 작아지면 페이지테이블의 크기가 커진다

<페이지 테이블>
페이지테이블은 cpu가 페이지의 실제 물리 주소를 찾는 방법이다
페이지테이블에 페이지번호와 프레임번호가 일대일 대응되어있다

페이징 시스템의 논리 주소: 페이지번호 + 변위

---

<PTBR, TLB>
CPU의 Page Table Base Register에 페이지테이블의 주소가 있고 이것을 참조해서 페이지테이블에 접근한다

페이지 테이블을 통해 페이지에 접근할때 메모리상에있는 페이지테이블에 접근후 다시 페이지에 접근하므로 메모리에 두번 접근하게 된다

접근횟수를 줄이기 위해 MMU에 Translation lookaside Buffer 캐시메모리를 만들어 그안에 참조지역성의 원리로 참조할것같은 페이지정보를 페이지테이블에서 가져온다
tlb에 접근하려는 페이지의 정보가 있으면 tlb hit , 없으면 tlb miss다

<페이지 테이블 엔트리>
페이지 테이블에는 페이지, 프레임 정보 말고도 다른 많은 정보가 들어있다

- 유효비트: 해당 페이지가 실제 메모리에 존재하는지 나타낸다
없으면 page fault 예외를 일으키고 페이지를 메모리에 올리는 작업을 한다
- 보호비트: 읽기, 쓰기, 실행 권한을 나타낸다
- 참조비트: 메모리 적재 이후 읽거나 쓴적이 있는 페이지
- 수정비트: 해당 페이지의 내용이 수정된적이 있는지 나타낸다, 수정된적이 없으면 이후에 메모리에서 삭제될때 그냥 삭제만 하면 되는데 수정된적이 있다면 보조기억장치의 내용도 수정해줘야 한다. 이를 표시하기 위한 비트이다


---

#### 페이징의 또 다른 이점
#### 쓰기 시 복사(자식 프로세스 생성시 메모리 아끼기)
copy on write
부모프로세스가 자식프로세스를 생성하면 부모의 프로세스가 그대로 복사되어 메모리에 똑같은 프로세스가 두개 올라온다
근데 이것은 메모리 낭비이다

그래서 읽기만 하는 경우에는 자식프로세스도 부모프로세스의 페이지를 가리키도록 페이지테이블이 만들어진다
그리고 자식프로세스에서 데이터를 수정하는 경우에 복사해서 메모리에 올리는것이 쓰기시 복사이다


---

## 계층적 페이징
hierarchical paging
multilevel page table

프로세스의 크기가 크면 페이지테이블의 크기도 크다
페이지테이블도 프로세스처럼 일부만 메모리에 올리기 위해 페이지로 나누고 나눠진 페이지테이블을 참조하는 outer table을 참조해서 페이지테이블을 참조한다

메모리에 없다면 보조기억장치에서 가져오면 된다

이렇게 페이지테이블은 여러 계층을 가질 수 있다.